Revision 0.10
-----------------------------

First release of libjpeg to the public.


Revision 0.11
-----------------------------

Apparently, the demo frontend code used the 
non-binary mode to open the output files,
creating corrupt files under platforms where
such modes include a text conversion. Fixed.

The configure script that tested for the avail-
ibility of setjmp did not work on those platforms
where setjmp is a macro rather than a function.
The test for setjmp is now omitted, depending solely
on the availability of longjmp.


Revision 0.20
-----------------------------

This release fixes a bug in the residual huffman decoder
scan where I forgot to multiply the residuals with the
quantization size. This did not affect lossless coding,
but only near-lossless coding.
Furthermore, this release adds coding of high-bitdepth
images with a standard 8bpp JPEG fallback stream. For
that, simply supply the image to be coded on the command
line and add the "-r" option to enable residual coding.
To use the conforming, but typically ill-supported 12bpp
mode of JPEG, do not use "-r".


Revision 0.30
-----------------------------

This release introduces a new coding strategy for lossless
and high-dynamic range coding. Unlike former releases,
this release runs an additional reversible color transformation
on the residual data, followed by a lossless (scaled) Hadamard
transformation to avoid color banding in extreme cases. It
also adds an additional tone mapping curve (or curves) to be
specified on encoding that allow a higher quality of the
LDR base layer.

Revision 0.50
-----------------------------

The new features in this version are a refined residual coding algorithm that
includes a runlength scan to improve coding efficiency for low-quality extensions
layers. This release also features a new HDR compression in the DCT domain that
uses the known JPEG refinement scans of progressive coding to improve the resolution
from 8 bit to 12 bit in a completely backwards compatible way. Additionally, the
software was unit-tested with the 10918-2 (JPEG part 2) test streams and various
bugs of the lossless predictive arithmetic coding and lossless predictive coding
were removed. New command line switches allow the encoding of pfm images (floating
point, for high-dynamic range) and the number of extension refinement scans.

Revision 0.60
-----------------------------

Only minor modifications were made in this release. The Huffman coder now fills
undefined bits at the end of the entropy coded segment by ones, and potentially
inserts a stuffed zero byte. Note that the standard defines this only in an
informative note, so it is likely not required. The insertion of a stuffed zero
byte at this position might also be unnecessary as a parser should identify the
first 0xff byte ahead of the marker as "fill byte".

Residual coding has been reworked and uses now a simple progressive scan with the
special DC case removed. The performance does not differ significantly, and it
makes integration into legacy software or hardware easier. 

Default Huffman tables are now also provided for progressive and lossless scans,
thus optimizing the Huffman tables just for these scan types is no longer 
necessary. Residual or refinement scans still require this argument, though.

Usage of the codec does not differ from previous releases, though codestreams
using the residual coding mode are not compatible to those generated by 0.5.
Note that this is still experimental software and the codestream might still
change until the ISO committee decides on the technology.

Finally, a couple of workarounds for earlier releases of the g++ compiler have
been added.


Release 0.7:
-----------------------------

This is a major release of the software which adds a lot of missing
functionality and brings it up to date to the latest working draft of
18477-2. In specific, boxes are now written according to the latest
specification, and three proposals to encode HDR data are now
implemented: mult1 (quotient method), mult2 (overflow/truncation
method) and residual coding. The HDR to LDR non-linear point
transformation can now be explicitly specified giving a file name on
the command line (-gf option) which must contain 256 lines, one line
per LDR input sample value. Each line shall contain an ASCII encoded
decimal number, the output value a reconstructed LDR sample value is
mapped to.

This release also supports (finally) subsampling in residual and
multiplicative coding, just specify the subsampling factors. In this
release, the frontend only allows the same subsampling factors for
both images (legacy and residual) though the back-end is more powerful
and would allow arbitrary combinations.  Lossless coding by residuals
is also supported, residual image subsampling factors are set to 1:1:1
in case the quality of the residual is 100.

The SERMS DCT that was removed in the earlier releases is now back and
can be enabled by the "-l" option. Note well that you also need to
specify "-c" to disable the YCbCr transformation.

The experimental VESA coding modes that have been part of this code
are now gone for good as they are not part of the specification.

A huge number of bugs have been fixed, in specific for the handling of
grey-only images. These should work fine now.

This release supports now two variations of the encoding mode,
open-loop and closed-loop.  In closed-loop coding, which was the
default so far, the residual/multiplicative encoder is feed by the
residual (additive or multiplicative) of the reconstructed LDR and
original image. For openloop coding, the encoder does not need to go
through a full encoding/decoding cycle of the legacy stream and feeds
in the legacy image derived from the original image to the residual
coder right away. NOTE THAT THIS MEANS THAT LOSSLESS CODING WILL NOT
OPERATIONAL IN OPEN LOOP MODE, and additive residual coding will be
rather pointless. However, this mode does make sense for the
multiplicative modes. Regardless of whether open or closed loop coding
is used, the encoded codestream is conforming, though coding results
may be different.


Release 0.71:
-----------------------------

This is a minor bugfix release which also adds one functionality, namely
the encodign of HDR images in the floating point domain via -mult1.
Previous versions took a round-trip through the integer domain and
hence required output clipping. The direct-float mode can now be enabled
by disabling the output-clipping process with "-oc". 

Additionally, this release fixes two bugs, mostly related to the internal
stream management. Due to an oversight, the marker-peek-ahead logic for
residual streams did not work, causing a potential race condition
when a marker was overlapping a chunk-boundary of the internal stream
representation. Length computation of the internal stream representation
was also broken on encoding, causing a potential race condition when the
huffman table marker was overlapping with a chunk boundary. A third
bug, namely a missing EOC at the end of the residual codestream, was
fixed, too.

Release 0.72:
-----------------------------

This release fixes a one-line oversight in the handling of subsampled "residual" coding,
namely the quantization output buffer did not advance, causing an assertion failure.
This release fixes the issue.


-------------------------------------------------------------------------------------

Release 0.8:

This is again an update of the software in order to synchronize it with
the latest Working Draft (proposed CD text) document; that is, boxes
are written now according to the latest specifications. Furthermore, support
for refinement scans in the residual domain have been added (with -rR),
residual data is DCT transformed unless lossless coding is desired.
This release also adds the checksum box, computes the checksum on encoding
and tests it on decoding. In case it does not fit, a warning is generated.

Quantization setup changed a bit, using now smaller buckets in the residual
stream which avoids the paradoxical situation that a finer base layer
quantization can cause a quality drop for the overall image.

A serious bug in legacy coding modes was removed that caused the encoder
or decoder to crash if no residual image was present.

This version of the encoder also supports encoding and decoding of images
in wider color spaces; for demonstration purposes, it encodes images in the
XYZ colorspace using the command line option -xyz, or -cxyz where the latter
uses a slightly less efficient method how to represent the images.

At this time, the text based format is not supported, and support for the
two other profiles (-mult1, -mult2) has been temporarely removed until the
standardization committee provides a clean solution how to integrate them.

-------------------------------------------------------------------------------------

Release 0.9:

This is just another update. This update introduces new DCTs, the Z0 DCT from
ISO/IEC 23002-2, the Z1a DCT from the same authors and the CD document of this
standard, and a lifting-based DCT. Tests show that Z0 and the lifting DCT do not 
perform very well, so the default is current Z1 and SERMS.
Furthermore, processing of RCT has changed slightly to ensure that the output
is always in-range, not only for 16 bit output.
DCT-bypass entropy coding was extended to use the full Huffman table, and includes
now special handling for the race-condition of having to code the value 0x8000
which was simply not possible before.
The codestream syntax has been modified again to reflect the latest edition of
the standard document, namely the CD of 18477-3.
Lots of other minor fixes have been made, as for example in the selection and
encoding of the precision of the residual frame and the computation of the
checksum.


-------------------------------------------------------------------------------------

Release 0.91:

This release fixes a wrong DC offset in the residual coding path that compromized
compression efficiency, and a wrong computation in the residual bits.

-------------------------------------------------------------------------------------

Release 0.92:

This release improves the computation of the LDR to HDR inverse TMO
computation for profile C and gains by that sometimes up to 2dB in
PSNR. It also provides a "-sp" command line switch to use separate
tables, one per component. This may help in case the image contains
some extreme colors.

-------------------------------------------------------------------------------------

Release 1.00alpha1:

This is the first complete release of the demo software. It adds again support
for profiles a and b for lossy HDR image coding and follows the new box-based
design of 18477-3.

-------------------------------------------------------------------------------------

Release 1.00beta1:

This is a fully verified version of the software, i.e. all modes of operation have
been tested by an automatic unit test. This of course does not exclude any bugs,
or any modifications before the finalization of the standard.

In comparison to the alpha1 release, the following bugs have been fixed:

- Predictive lossless mode with restart markers forgot to reconstruct the last line
in some configurations.
- Due to an oversight, hierarchical mode did not work in combination with AC coding.
- Hierarchical mode did not work in the "semi-lossless" configuration where the finest
frame is defined by a lossless predictive scan.
- Predictive lossless could have forgotten the last line on streams using the DNL marker
to signal the height of the image.
- JPEG LS restart markers did not work in plane and sample interleaved mode. Note,
however, that restart marker handling in the JPEG LS reference software is broken and
does not follow the specifications. (Defect report is pending.)
- Grey scale coding in profiles A and B did not work.
- Coding in RGB-colorspace did not work in profiles A and B.
- Encoding in JPEG-LS erraneously inserted JPEG XT boxes into the codestream. While this
is harmless, it increases the rate unnecessarily.

-------------------------------------------------------------------------------------

Release 1.00beta2:

This release includes the changes made on the standard in the Strasbourg meeting
of the JPEG committee, in particular it includes a rounding mode specifier of
the CURV boxes. Additionally, it allows now the inclusion of an arbitrary LDR image
within profile B. Previous releases only supported the gamma-plus-clamping tone
mapper which was built into the source. In addition to the new features, this
release also includes an improved Huffman decoder that should be considerably
faster than the previous trivial bit-by-bit decoder.

-------------------------------------------------------------------------------------

Release 1.00beta2.2:

Only a short fix in the handling of lossless JPEG scans: This release fixes one
issue, namely correct decoding of 16-bit images where the carry-over was not
computed correctly. This change required a careful distinction between differential
predictive and regular-predictive mode, which is interestingly not mentioned in
the specs (probably nobody tested). A second race was fixed in JPEG-LS handling
where bit-stuffing could have left a single isolated zero at the end of a JPEG-LS
scan, causing a warning in the upwards marker parser (though no corrupt reconstruction).

-------------------------------------------------------------------------------------

Release 1.20:

This version adds support for alpha channels as defined by ISO/IEC 18477-9
to the code. Alpha channels are specified by one-component grey-scale images,
of bit depths between 8 and 16 bits per sample. They may also consist of
floating point samples between 0 and 1. To add an alpha channel, use the command
line options -al <filename> -aq <quality> for simple alpha channels of 8 bits per
sample. For more precise alpha channels, residual coding in the alpha domain
must be enabled with -ar, and an alpha channel residual quality must be specified
with -aQ <ext-quality>. The coding tools for alpha channels are otherwise identical
for that of the base image. Alpha coding can be combined with any other coding
tools, i.e. parts 6,7 and 8.

-------------------------------------------------------------------------------------

Release 1.21:

This is only a minor maintenance release which removes three experimental DCT
implementations that are no longer required, fixes two possible un-initialized
variables and fixes a bug in the box enumeration. Release 1.20 and above started
for some boxes the box enumeration at zero even though it should start at one.

-------------------------------------------------------------------------------------

Release 1.30:

This release fixes a bug in the line-based operation mode that is not available from
the front end and only works for baseline sequential. Unlike other modes, it does
not require full internal buffering of the image. It is also synchronized again to
the latest edition of the standard, offering the additional upscaling in the residual
path for parts 6 and part 7 profile C. It has been cross-tested with other 
implementations, thus interoperability is granted. Clipping for floating-point output
has been corrected to avoid the representations of NAN and INF.
Last but not least, this release offers the possibility to select between nine different
quantization matrices (-qt 0 to -qt 9), of which -qt 1 is PSNR-optimal and -qt 3 is
a good candidate for high visual compression. See the command line parameters for
details. Furthermore, the -dz parameter enables a deadzone quantizer that improves
the compression performance by 0.3 dB on average.

-------------------------------------------------------------------------------------

Release 1.31:

This release includes two minor changes that have been made to the specs at the last 
Warsaw meeting in June 2015. The order of the FDCT (fixed point DCT) has been adjusted
to match the order of ISO/IEC 23002-2 (MPEG C) and to be consistent with the order of
the IDCT (integer DCT). Second, the specs allow now Integer Table Lookup boxes with
sample size > 16 bits to allow the usage of a Table lookup in the residual coding
path for part 8 of the specs.

-------------------------------------------------------------------------------------

Release 1.40:

In this release, we included additional support for "full profile" encoding, i.e.
encoding parameters that do not fit any of the four profiles specified in 18477-7.
Using such encoding parameters will generate a warning on the command line, but
encoding will proceed anyhow, generating a bitstream that conforms to 18477-7, but
not to any of the profiles in this standard.

With "-profile a -g 0" or "-profile b -g 0" the encoder will generate a file that
uses an inverse TMO lookup similar to profile C with other encoding parameters
identical to those defined by profiles A and B.

The command line option "-lr" will use a logarithmic encoding instead of the gamma
encoding for profile B. Again, this will leave the profile, but will be within the
bounds of 18477-7.

Other than that, a couple of bug fixes have been made. Profile A and B setup could
not reset the toe value for the inverse gamma map, due to a typo of one of the
parameters. Profile B accepted a different gamma value than the default, but never
communicated it to the core code, i.e. it was simply ignored. Profile B setup ignored
the epsilon values for numerator and denomiator, and they were communicated wrongly
into the core code. This was corrected, and epsilons can now be specified on the
command line. The JPEG LS part-2 encoder was broken due to a modification of the
color transformer factory, and the (non-standardized, proprietary) residual
refinement arithmetic coding scan mode did not work correctly by depending on a non-
existing context.

-------------------------------------------------------------------------------------

Release 1.50:

This release fixes encoding of ISO/IEC 18477-8 if the IDCT was selected as
transformation in the extension layer and refinement scans were added, i.e.
the command line options -rl -rR 4 created invalid codestreams. Previous
releases used the wrong type of refinement scan (dct bypass refinement instead
of regular refinement) and hence broke reconstruction. Furthermore, previous
releases no longer allowed near lossless coding with DCT bypass. Instead, regular
DCT coding conforming to ISO/IEC 18477-7 was used. To enable the near-lossless
DCT bypass mode, use the new option "-ro" now.

Profile B encoding could potentially create codestreams that run into
clipping of the extension channel; this always happens if the denominator is
larger than 1, and has to happen according to Annex C of ISO/IEC 18477-3:2015.
This release avoids this issue by adjusting the exposure value such that
the denominator always remains smaller than 1.

--------------------------------------------------------------------------

Release 1.51:

If the JPEG-XT markers were delayed to the frame-header instead the global
header, the previous code did not built up the necessary infrastructure
to compute the checksum and hence could not verify the checksum in such
a condition. The 1.51 release fixes this problem.

-------------------------------------------------------------------------------------

Release 1.52:

This file is an updated/enhanced version of the 1.50 release of
the JPEG XT demo software found on https://github.com/thorfdbg/. It
includes additional features presented in the paper
"JPEG on Steroids : Common Optimization Techniques for JPEG Image Compression"
by the same author.

In specific, the following command line flags are *NEW* to this version and
are available only as a contribution to ICIP 2016:

-oz:	      This enables the dynamic programming algorithm to enhance
the rate-distortion performance by soft-threshold quantization. It has been
used for the tests in section 3.3 of the paper.

-dr: 	     This enables the smart de-ringing algorithm that has been used
in section 3.6.

Additionally, the following switches have been used for other subsections
of the paper; they are not new to this distribution but available as
part of the regular libjpeg distribution at github or www.jpeg.org:

-s 1x1,2x2,2x2:	    Enable 420 subsampling (444 is default)
-s 1x1,2x1,2x1:	    Enable 422 subsampling (444 is default)
-qt n (n=0..8)	    Use quantization matrix n.
      		    In the paper, n=1 (flat) was used for PSNR-optimized
		    coding, unless otherwise noted.
-dz		    The deadzone quantizer in section 3.3
		    (simpler than -oz)
-v		    Enable coding in processive mode (section 3.5)
-v -qv		    Optimized progressive mode (section 3.5)
-h 		    Optimized Huffman coding (always used, unless noted
		    otherwise, see section 3.4)

--------------------------------------------------------------------------

Release 1.53:

This release includes additional functionality to inject markers, or
retrieve markers from a codestream while reading. For that, set
the JPGTAG_ENCODER_STOP tag of the JPEG::Write() call to a bitmask
where the encoder should interrupt writing data (this flag already
existed before) then write custom data with JPEG::WriteMarker(), then
continue with JPEG::Write(). On decoding, set JPGTAG_DECODER_STOP to
a bitmask where to stop for markers, then identify markers with
JPEG::PeekMarker(), and retrieve them with JPEG::ReadMarker(). Details
can be found in cmd/encodec.cpp for encoding, and cmd/reconstruct.cpp.

Otherwise, no functional changes.

--------------------------------------------------------------------------

Release 1.54:

In this release, upsampling has been made conforming to the latest
corrigendum of 18477-1 and 18477-8. In particular, upsampling is now
by design always centered and never co-sited. The co-sited upsampling
procedure is still included in the source code, but never executed.

--------------------------------------------------------------------------

Release 1.55:

This release only addresses some minor formulation issues of the
command line such that references are formatted properly to make this
software package acceptable as a JPEG reference software.
No functional changes.

--------------------------------------------------------------------------

Release 1.56:

Encoding and reconstruction of 2-component images was actually never
supported, as it was considered a rather exotic use-case. Now that a
request was made, support for 2-components was added and should
hopefully work ok.

--------------------------------------------------------------------------

Release 1.57:

Newer g++ compiler versions warned about implicit fall-throughs in switch/
case constructs that are actually harmless. This release adds an autoconf
detection of such compiler versions, adds consistent comments throughout
the code, and disables the compiler warning were necessary.

--------------------------------------------------------------------------

Release 1.58:

This release fixes multiple spelling errors in the file, thanks to
Mathieu Mmalaterre for finding and fixing them. The release also
addresses multiple race conditions and improves stability and robustness
on invalid streams. Thanks to seviezhou for providing codestreams that
triggered these defects. In particular, the following defects have
been found:

- when a codestream with unsupported upsampling specification (beyond
  18477-1) was found, the code crashed.
- JPEG LS single component scans did not check whether there is actually
  only a single component referenced in the scan.
- An invalid DC category in the sequential scan could have caused a
  crash in the follow-up decoding.
- AC-coded lossless JPEG scans with horizontal subsampling factors
  trashed memory.
- MCU sizes of 0 remained undetected and caused crashes due to a
  division-by-zero exception.
- The code did not check whether a scan references the same component
  more than once and could have failed with strange effects then.
- The code did not handle EOF conditions in the frame header
  gracefully.

--------------------------------------------------------------------------

Release 1.59:

This release addresses a defect in the MCU handling for JPEG LS scans.
The previous code forgot to reset the JPEG LS state variables on MCU
scan boundaries, thus defeating the independent decodability of MCUs
if restart markers are inserted into the stream. Thanks to Spyros for
detecting this defect.

--------------------------------------------------------------------------

Release 1.60:

A specially crafted bitstream depending on line-based JPEG processes
could trigger a segfault because source data the reconstruction
process depended upon were not available. This has been fixed.

--------------------------------------------------------------------------

Release 1.61:

The restart interval for JPEG LS streams, specifically, is allowed to
be larger than 2^16. Modified the DRI marker accordingly. Unfortunately,
as the initial tables section of a codestream of JPEG and JPEG LS is
identical, JPEG files with an invalid DRI marker size will also be
accepted as valid.

--------------------------------------------------------------------------

Release 1.62:

The quantization table could contain entries larger than 255 for the 8-bit
DCT process, even though the standard prohibits this. Now the quantization
table entries are clipped to the allowed range.
Added an option -bl to force encoding in the baseline sequential process.
Added options to read the quantization tables from files rather than using
the built-in defaults.

--------------------------------------------------------------------------

Release 1.63:

In case the decoder was started with an image containing an alpha channel,
i.e. a 18477-9 image, and no output file for the alpha channel was
provided, the decoder crashed. This issue was fixed, the alpha channel is
now in this case simply disregarded. Note that you can define the output
file for the alpha channel with the "-al" command line option.

--------------------------------------------------------------------------

Release 1.64:

The lossless scan, the arithmetically coded lossless scan and the
arithmetically coded sequential scan could run into cases where an
out-of-bounds symbol triggered and out-of-bounds array access and could
have crashed the decoder. The code is now more carefully changing the
validity of the symbols and aborts with an error if it finds illegal
codes.
The code now also checks the consistency of the MCU sizes in the
hierarchical process and fails if they differ across levels.

--------------------------------------------------------------------------

Release 1.65:

The components requested through DisplayRectangle() are always codestream
component (i.e. Y, U, V) and not RGB components in the target image.
This led to some confusion and lack of initialization of bitmap descriptors
if less components were requested than present in the image.
The large-range scan did not properly check whether the DCT precision exceeds
the range decodable by the Huffman encoder. It now aborts faithfully if such
coefficients are detected.
The code did not check if the number of components present in a JPEG LS-2
transformation are identical to the number of components indicated in the
frame header. The code now aborts with an error if such a condition is
detected.

--------------------------------------------------------------------------

Release 1.66:

Previous releases had no means to signal an error from within the BitMapHook.
Now the return code of the BitMapHook call back function, if non-zero, is
used as an error, and such an error is then reported upstream to the caller.

Note that the supplied bitmap hook in the "cmd" directory is only an example
and does not validate inputs. The encoder, in particular, operates on a
"garbadge-in garbadge-out" basis. If the samples in the bitmap hook exceed
the range indicated to the library, bad things will happen. That is, if the
encoder is supposed to operate within an unknown environment with unknown
input data, input validation is required within the bitmap hook.

THE SAMPLE CODE DOES NOT ATTEMPT TO VALIDATE INPUT

Similar restrictions applies to the "PNM" helper code (or any code) in the
cmd directory. It does not attempt to validate input. At least some
minimal attempts to ensure that input files are valid is now in place, but
real life deployment of the code should contain more checks.

--------------------------------------------------------------------------

Release 1.67:

- Fixed a potential memory leak where the code did not release residual
or alpha tables on some error conditions.
- Fixed missing valiation for hidden residual DCT scans where start and
stop bitplane must be one bitplane appart.
- Fixed the box parser where boxes were attempted to be parsed that were
not yet completely loaded.
- Invalid PPM files that indicate a bitdepth > 16 are now detected and
generate an early error condition.
- Encoding images with an alpha channel was not working due to a lack
of enabling the alpha channel with a suitable tag.
- The Adobe marker with version 101 is now also decoded, though despite
the color transformation, flags are disregarded. Smoothing is not
supported by this implementation.

--------------------------------------------------------------------------

Release 1.68:
- Fixed a missing initialization of the table owner holder introduced
  in 1.67.
  
--------------------------------------------------------------------------

Release 1.69:
- The DC Huffman table for the lossless predictive process also contained
  entries for symbols of 17 and above for unknown reasons that might have
  confused some other implementations. As these symbols are never needed,
  they have been removed.

--------------------------------------------------------------------------

Release 1.70:
- The decoding of predictive JPEGs aborted premature if the DNL marker was
  found, but the AC or Huffman decoder contained sufficient state information
  to cover at least one line of data. In such a case, the DNL marker was
  hit before the end of the next line was hit, even though parts of the
  current line and the next line were still covered by the data in the AC
  or Huffman decoder. I want to thank Robert Ancell for reporting this defect
  and providing a fix.
